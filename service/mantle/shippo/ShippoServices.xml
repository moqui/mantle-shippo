<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a 
Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domain Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-3.xsd">

    <!-- ========== Rate (Estimate) Services ========== -->

    <service verb="get" noun="OrderShippingRate">
        <!-- see: https://goshippo.com/docs/reference#shipments -->
        <implements service="mantle.shipment.CarrierServices.get#OrderShippingRate"/>
        <actions>
            <entity-find-one entity-name="mantle.shipment.carrier.ShippingGatewayOption" value-field="apiTokenOpt">
                <field-map field-name="shippingGatewayConfigId"/><field-map field-name="optionEnumId" value="SgoApiToken"/></entity-find-one>
            <set field="apiToken" from="apiTokenOpt?.optionValue"/>
            <if condition="!apiToken"><log level="warn" message="Shipping gateway ${shippingGatewayConfigId} has no SgoApiToken, not getting rates"/><return/></if>

            <if condition="!packageInfoList"><return message="No package info found, not getting Shippo shipping rates"/></if>

            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"/>
            <entity-find-one entity-name="mantle.order.OrderPart" value-field="orderPart"/>

            <set field="fromPartyId" from="orderPart.vendorPartyId"/>
            <if condition="!fromPartyId"><return message="Vendor party not set on order part ${orderId}:${orderPartSeqId}"/></if>
            <set field="toPartyId" from="orderPart.customerPartyId"/>
            <if condition="!toPartyId"><return message="To party not set on order part ${orderId}:${orderPartSeqId}"/></if>

            <set field="carrierPartyId" from="carrierPartyId ?: orderPart.carrierPartyId"/>
            <if condition="!carrierPartyId || carrierPartyId == '_NA_'"><return message="Carrier not set on order part ${orderId}:${orderPartSeqId}"/></if>
            <set field="shipmentMethodEnumId" from="shipmentMethodEnumId ?: orderPart.shipmentMethodEnumId"/>
            <if condition="!shipmentMethodEnumId"><return message="Shipment method not set on order part ${orderId}:${orderPartSeqId}"/></if>

            <!-- address_from -->
            <if condition="!orderPart.facilityId"><return message="Facility not set on order part ${orderId}:${orderPartSeqId}"/></if>
            <service-call name="mantle.facility.ContactServices.get#FacilityDefaultShipOrigin" out-map="facOriginOut"
                    in-map="[facilityId:orderPart.facilityId]"/>
            <if condition="!facOriginOut.postalContactMechId"><return message="Facility ${orderPart.facilityId} on order part ${orderId}:${orderPartSeqId} has no ship origin address"/></if>
            <entity-find-one entity-name="mantle.party.contact.PostalAddress" value-field="originPostalAddress">
                <field-map field-name="contactMechId" from="facOriginOut.postalContactMechId"/></entity-find-one>
            <if condition="!originPostalAddress.shipGatewayAddressId">
                <service-call name="mantle.shippo.ShippoServices.validate#PostalAddress" out-map="fromValidateOut"
                        in-map="[contactMechId:facOriginOut.postalContactMechId, partyId:fromPartyId, facilityId:orderPart.facilityId,
                            shippingGatewayConfigId:shippingGatewayConfigId]"/>
                <entity-find-one entity-name="mantle.party.contact.PostalAddress" value-field="originPostalAddress">
                    <field-map field-name="contactMechId" from="fromValidateOut.contactMechId"/></entity-find-one>
            </if>

            <entity-find-one entity-name="mantle.party.contact.ContactMech" value-field="originContactMech">
                <field-map field-name="contactMechId" from="originPostalAddress.contactMechId"/></entity-find-one>
            <if condition="originPostalAddress.shipGatewayAddressId &amp;&amp; originContactMech.trustLevelEnumId in ['CmtlValid', 'CmtlVerified']"><then>
                <set field="address_from" from="originPostalAddress.shipGatewayAddressId"/>
            </then><else>
                <service-call name="mantle.shippo.ShippoServices.get#AddressMap" out-map="originAddrOut"
                        in-map="[postalAddress:originPostalAddress, partyId:fromPartyId, isOrigin:true]"/>
                <set field="address_from" from="originAddrOut.addressMap"/>
            </else></if>

            <!-- address_to -->
            <if condition="!orderPart.postalContactMechId"><return message="Address not set on order part ${orderId}:${orderPartSeqId}"/></if>
            <entity-find-one entity-name="mantle.party.contact.PostalAddress" value-field="destPostalAddress">
                <field-map field-name="contactMechId" from="orderPart.postalContactMechId"/></entity-find-one>
            <if condition="!destPostalAddress.shipGatewayAddressId">
                <service-call name="mantle.shippo.ShippoServices.validate#PostalAddress" out-map="toValidateOut"
                        in-map="[contactMechId:orderPart.postalContactMechId, partyId:toPartyId, shippingGatewayConfigId:shippingGatewayConfigId]"/>
                <set field="postalContactMechId" from="toValidateOut.contactMechId"/>
                <set field="orderPart.postalContactMechId" from="postalContactMechId"/>
                <entity-update value-field="orderPart"/>

                <entity-find-one entity-name="mantle.party.contact.PostalAddress" value-field="destPostalAddress">
                    <field-map field-name="contactMechId" from="orderPart.postalContactMechId"/></entity-find-one>
            </if>

            <entity-find-one entity-name="mantle.party.contact.ContactMech" value-field="destContactMech">
                <field-map field-name="contactMechId" from="destPostalAddress.contactMechId"/></entity-find-one>
            <if condition="destPostalAddress.shipGatewayAddressId &amp;&amp; destContactMech.trustLevelEnumId in ['CmtlValid', 'CmtlVerified']"><then>
                <set field="address_to" from="destPostalAddress.shipGatewayAddressId"/>
            </then><else>
                <service-call name="mantle.shippo.ShippoServices.get#AddressMap" out-map="destAddrOut"
                        in-map="[postalAddress:destPostalAddress, partyId:toPartyId, isOrigin:false]"/>
                <set field="address_to" from="destAddrOut.addressMap"/>
            </else></if>

            <!-- carrier_account, servicelevel_token -->
            <entity-find-one entity-name="mantle.shipment.carrier.ShippingGatewayCarrier" value-field="gatewayCarrier"/>
            <set field="carrier_account" from="gatewayCarrier?.gatewayAccountId"/>
            <if condition="!carrier_account"><return message="No Shippo account ID found for carrier ${carrierPartyId} in gateway ${shippingGatewayConfigId}"/></if>
            <entity-find-one entity-name="mantle.shipment.carrier.CarrierShipmentMethod" value-field="carrierShipmentMethod"/>
            <set field="servicelevel_token" from="carrierShipmentMethod?.gatewayServiceCode"/>
            <if condition="!servicelevel_token"><return message="No Shippo service level code found for carrier ${carrierPartyId} method ${shipmentMethodEnumId}"/></if>

            <!-- NOTE: because Shippo treats multiple parcels as a multi-piece shipment (only supported by UPS, FedEx?) do one call per package -->
            <!-- parcels -->
            <set field="shippingTotal" from="0.0"/>
            <set field="servicelevelMap" from="null"/>
            <iterate list="packageInfoList" entry="packageInfo">
                <!-- parcel -->
                <entity-find-one entity-name="mantle.shipment.ShipmentBoxType" value-field="boxType">
                    <field-map field-name="shipmentBoxTypeId" from="packageInfo.shipmentBoxTypeId"/></entity-find-one>
                <if condition="boxType == null"><message>Package has no box type, skipping</message><continue/></if>

                <set field="dimUom" from="boxType.dimensionUom"/>
                <if condition="!boxType.boxLength || !boxType.boxWidth || !boxType.boxHeight || dimUom == null">
                    <message>Box type ${boxType.shipmentBoxTypeId} is missing dimensions (length, width, height) or dimension UOM, skipping package</message><continue/></if>
                <entity-find-one entity-name="moqui.basic.Uom" value-field="weightUom">
                    <field-map field-name="uomId" from="packageInfo.weightUomId ?: 'WT_lb'"/></entity-find-one>
                <set field="weight" from="packageInfo.weight ?: boxType.defaultGrossWeight"/>
                <if condition="!weight || weightUom == null">
                    <message>Package ${packageInfo_index} box type ${boxType.shipmentBoxTypeId} is missing weight or weight UOM, skipping package</message><continue/></if>

                <set field="distance_unit" from="dimUom.abbreviation"/>
                <if condition="!(distance_unit in ['cm', 'in', 'ft', 'mm', 'm', 'yd'])">
                    <message>Package ${packageInfo_index} box type ${boxType.shipmentBoxTypeId} dimension unit is '${distance_unit}', must be one of: 'cm', 'in', 'ft', 'mm', 'm', 'yd'; skipping package</message><continue/></if>
                <set field="mass_unit" from="weightUom.abbreviation"/>
                <if condition="!(mass_unit in ['g', 'oz', 'lb', 'kg'])">
                    <message>Package ${packageInfo_index} box type ${boxType.shipmentBoxTypeId} weight unit is '${mass_unit}', must be one of: 'g', 'oz', 'lb', 'kg'; skipping package</message><continue/></if>

                <set field="parcel" from="[length:boxType.boxLength, width:boxType.boxWidth, height:boxType.boxHeight,
                            distance_unit:distance_unit, weight:weight, mass_unit:mass_unit, template:boxType.gatewayBoxId]"/>
                <set field="parcels" from="[parcel]"/>

                <!-- add extra.insurance if applicable -->
                <service-call name="mantle.shipment.CarrierServices.get#GeneralPackageRequiresInsurance" out-map="insuranceReqOut" out-map-add-to-existing="false"
                        in-map="[quantityByProductId:packageInfo.quantityByProductId, currencyUomId:orderHeader.currencyUomId,
                            productStoreId:orderHeader.productStoreId, vendorPartyId:orderPart.vendorPartyId]"/>
                <if condition="insuranceReqOut.insuranceRequired &amp;&amp; insuranceReqOut.packageTotalCost">
                    <!-- parcel.extra.insurance.amount, currency, provider, content -->
                    <!-- FUTURE: support for provider field, initial implementation for Shippo's Shipsurance where no provider is specified
                        see: https://goshippo.com/docs/insurance/?_ga=2.131195663.1849014295.1614148616-176427592.1614050676 -->
                    <set field="parcel.extra" from="[insurance:[amount:insuranceReqOut.packageTotalCost, currency:currencyUomId,
                            content:insuranceReqOut.contentDescription]]"/>
                </if>

                <!-- assemble the full request Map -->
                <set field="requestMap" from="[address_from:address_from, address_to:address_to,
                    parcels:parcels, carrier_accounts:[carrier_account], async:false, extra:[bypass_address_validation:true]]"/>
                <!-- NOTE: any way to pass servicelevel_token(s) to limit in advance? for now just filtering after -->

                <!-- <log level="warn" message="Shippo rate order ${orderId} request:\n${requestMap}"/> -->

                <script><![CDATA[
                    org.moqui.util.RestClient restClient = ec.service.rest().method(org.moqui.util.RestClient.POST)
                            .addHeader("Authorization", "ShippoToken ${apiToken}")
                            .addHeader("Shippo-API-Version", "2018-02-08")
                            .addHeader("Content-Type", "application/json").jsonObject(requestMap)
                    restClient.uri().protocol("https").host("api.goshippo.com").port(443).path("shipments").build()
                    org.moqui.util.RestClient.RestResponse restResponse = restClient.call()
                    if (restResponse.statusCode < 200 || restResponse.statusCode >= 300) {
                        // based on code in Shippo Java client will return error message in plain text body
                        String errMsg = restResponse.text()
                        ec.logger.error("Shippo error response (${restResponse.statusCode}): ${errMsg}")
                        ec.message.addMessage("Shippo API error")
                        ec.message.addMessage(errMsg)
                        return
                    }
                    responseMap = restResponse.jsonObject()
                ]]></script>

                <!-- <log level="warn" message="Shippo rate order ${orderId} response: ${responseMap}"/> -->

                <!-- show messages -->
                <if condition="responseMap.messages"><iterate list="responseMap.messages" entry="messageObj">
                    <message>(${messageObj.source}:${messageObj.code}) ${messageObj.text}</message></iterate></if>

                <if condition="responseMap.status != 'SUCCESS'"><message>Shippo rate status ${responseMap.status} for package</message></if>

                <!-- find the rate matching the servicelevel_token -->
                <iterate list="responseMap.rates" entry="rateMap">
                    <if condition="rateMap?.servicelevel?.token == servicelevel_token">
                        <set field="curShippingTotal" from="rateMap.amount as BigDecimal"/>
                        <set field="shippingTotal" from="shippingTotal + curShippingTotal"/>
                        <set field="servicelevelMap" from="rateMap.servicelevel"/>
                        <break/>
                    </if>
                </iterate>
            </iterate>

            <!-- create an OrderItem for it if applicable -->
            <if condition="createOrderItem &amp;&amp; shippingTotal &gt; 0.0">
                <entity-find-one entity-name="mantle.party.Party" value-field="carrierParty">
                    <field-map field-name="partyId" from="carrierPartyId"/></entity-find-one>
                <entity-find-one entity-name="moqui.basic.Enumeration" value-field="shipmentMethodEnum">
                    <field-map field-name="enumId" from="orderPart.shipmentMethodEnumId"/></entity-find-one>
                <set field="itemDescription" value="${carrierParty.pseudoId} ${servicelevelMap.name ?: shipmentMethodEnum.description}"/>
                <set field="comments" value=""/>
                <iterate list="parcels" entry="parcel">
                    <if condition="comments"><set field="comments" from="comments + ', '"/></if>
                    <set field="comments" value="${comments}${parcel.length}x${parcel.width}x${parcel.height}${parcel.distance_unit} ${parcel.weight}${parcel.mass_unit}"/>
                </iterate>
                <service-call name="create#mantle.order.OrderItem" out-map="context" in-map="[orderId:orderId, orderPartSeqId:orderPartSeqId,
                        itemTypeEnumId:'ItemShipping', quantity:1, unitAmount:shippingTotal, itemDescription:itemDescription, comments:comments]"/>
            </if>
        </actions>
    </service>
    <service verb="get" noun="ShippingRatesBulk">
        <!-- see: https://goshippo.com/docs/reference#shipments -->
        <implements service="mantle.shipment.CarrierServices.get#ShippingRatesBulk"/>
        <out-parameters><parameter name="rateInfoByServiceLevelByPackage" type="Map"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.shipment.carrier.ShippingGatewayOption" value-field="apiTokenOpt">
                <field-map field-name="shippingGatewayConfigId"/><field-map field-name="optionEnumId" value="SgoApiToken"/></entity-find-one>
            <set field="apiToken" from="apiTokenOpt?.optionValue"/>
            <if condition="!apiToken"><log level="warn" message="Shipping gateway ${shippingGatewayConfigId} has no SgoApiToken, not getting rates"/><return/></if>

            <if condition="!packageInfoList"><return message="No package info found, not getting Shippo shipping rates"/></if>
            <if condition="!carrierShipmentMethodList"><return message="No carrier/method list, not getting Shippo shipping rates"/></if>

            <!-- address_from -->
            <entity-find-one entity-name="mantle.party.contact.PostalAddress" value-field="originPostalAddress">
                <field-map field-name="contactMechId" from="originPostalContactMechId"/></entity-find-one>
            <if condition="!originPostalAddress.shipGatewayAddressId">
                <service-call name="mantle.shippo.ShippoServices.validate#PostalAddress" out-map="fromValidateOut"
                        in-map="[contactMechId:originPostalContactMechId, partyId:fromPartyId, facilityId:originFacilityId,
                            shippingGatewayConfigId:shippingGatewayConfigId]"/>

                <set field="originPostalContactMechId" from="fromValidateOut.contactMechId"/>
                <entity-find-one entity-name="mantle.party.contact.PostalAddress" value-field="originPostalAddress">
                    <field-map field-name="contactMechId" from="originPostalContactMechId"/></entity-find-one>
            </if>

            <entity-find-one entity-name="mantle.party.contact.ContactMech" value-field="originContactMech">
                <field-map field-name="contactMechId" from="originPostalContactMechId"/></entity-find-one>
            <if condition="originPostalAddress.shipGatewayAddressId &amp;&amp; originContactMech.trustLevelEnumId in ['CmtlValid', 'CmtlVerified']"><then>
                <set field="address_from" from="originPostalAddress.shipGatewayAddressId"/>
            </then><else>
                <service-call name="mantle.shippo.ShippoServices.get#AddressMap" out-map="originAddrOut"
                        in-map="[postalAddress:originPostalAddress, partyId:fromPartyId, isOrigin:true]"/>
                <set field="address_from" from="originAddrOut.addressMap"/>
            </else></if>

            <!-- address_to -->
            <entity-find-one entity-name="mantle.party.contact.PostalAddress" value-field="destPostalAddress">
                <field-map field-name="contactMechId" from="destPostalContactMechId"/></entity-find-one>
            <if condition="!destPostalAddress.shipGatewayAddressId">
                <service-call name="mantle.shippo.ShippoServices.validate#PostalAddress" out-map="toValidateOut"
                        in-map="[contactMechId:destPostalContactMechId, partyId:toPartyId, orderId:orderId, shipmentId:shipmentId,
                            shippingGatewayConfigId:shippingGatewayConfigId]"/>

                <set field="destPostalContactMechId" from="toValidateOut.contactMechId"/>
                <entity-find-one entity-name="mantle.party.contact.PostalAddress" value-field="destPostalAddress">
                    <field-map field-name="contactMechId" from="destPostalContactMechId"/></entity-find-one>
            </if>

            <entity-find-one entity-name="mantle.party.contact.ContactMech" value-field="destContactMech">
                <field-map field-name="contactMechId" from="destPostalContactMechId"/></entity-find-one>
            <if condition="destPostalAddress.shipGatewayAddressId &amp;&amp; destContactMech.trustLevelEnumId in ['CmtlValid', 'CmtlVerified']"><then>
                <set field="address_to" from="destPostalAddress.shipGatewayAddressId"/>
            </then><else>
                <service-call name="mantle.shippo.ShippoServices.get#AddressMap" out-map="destAddrOut"
                        in-map="[postalAddress:destPostalAddress, partyId:toPartyId, isOrigin:false]"/>
                <set field="address_to" from="destAddrOut.addressMap"/>
            </else></if>

            <!-- carrier_accounts, servicelevel_token reverse Map -->
            <set field="carrier_accounts" from="[]"/>
            <set field="carrierPartyIdSet" from="new HashSet()"/>
            <set field="carrierMethodByServiceLevel" from="[:]"/>
            <iterate list="carrierShipmentMethodList" entry="carrierMethod">
                <if condition="!carrierPartyIdSet.contains(carrierMethod.carrierPartyId)">
                    <entity-find-one entity-name="mantle.shipment.carrier.ShippingGatewayCarrier" value-field="gatewayCarrier" cache="true">
                        <field-map field-name="shippingGatewayConfigId"/><field-map field-name="carrierPartyId" from="carrierMethod.carrierPartyId"/></entity-find-one>
                    <if condition="gatewayCarrier?.gatewayAccountId">
                        <then><script>carrier_accounts.add(gatewayCarrier.gatewayAccountId)</script></then>
                        <else><!-- <message>No gateway account ID found for carrier ${carrierMethod.carrierPartyId} in gateway ${shippingGatewayConfigId}</message> --></else>
                    </if>
                    <script>carrierPartyIdSet.add(carrierMethod.carrierPartyId)</script>
                </if>

                <entity-find-one entity-name="mantle.shipment.carrier.CarrierShipmentMethod" value-field="carrierMethodValue" cache="true">
                    <field-map field-name="carrierPartyId" from="carrierMethod.carrierPartyId"/>
                    <field-map field-name="shipmentMethodEnumId" from="carrierMethod.shipmentMethodEnumId"/>
                </entity-find-one>
                <if condition="carrierMethodValue?.gatewayServiceCode">
                    <then><script>carrierMethodByServiceLevel.put(carrierMethodValue.gatewayServiceCode, carrierMethodValue)</script></then>
                    <else><!-- <message>No Shippo service level code found for carrier ${carrierMethod.carrierPartyId} method ${carrierMethod.shipmentMethodEnumId}</message> --></else>
                </if>
            </iterate>
            <if condition="!carrierMethodByServiceLevel">
                <!-- no point doing the Shippo request as we'll ignore all results -->
                <set field="shippingRateInfoList" from="[]"/>
                <return/>
            </if>

            <!-- NOTE: because Shippo treats multiple parcels as a multi-piece shipment (only supported by UPS, FedEx?) do one call per package -->
            <!-- parcels -->
            <set field="requestMapList" from="[]"/>
            <set field="requestPackageIdList" from="[]"/>
            <iterate list="packageInfoList" entry="packageInfo">
                <!-- parcel -->
                <entity-find-one entity-name="mantle.shipment.ShipmentBoxType" value-field="boxType">
                    <field-map field-name="shipmentBoxTypeId" from="packageInfo.shipmentBoxTypeId"/></entity-find-one>
                <if condition="boxType == null"><message>Package has no box type, skipping</message><continue/></if>

                <set field="dimUom" from="boxType.dimensionUom"/>
                <if condition="!boxType.boxLength || !boxType.boxWidth || !boxType.boxHeight || dimUom == null">
                    <message>Box type ${boxType.shipmentBoxTypeId} is missing dimensions (length, width, height) or dimension UOM, skipping package</message><continue/></if>
                <entity-find-one entity-name="moqui.basic.Uom" value-field="weightUom">
                    <field-map field-name="uomId" from="packageInfo.weightUomId ?: 'WT_lb'"/></entity-find-one>
                <set field="weight" from="packageInfo.weight ?: boxType.defaultGrossWeight"/>
                <if condition="!weight || weightUom == null">
                    <message>Package ${packageInfo_index} box type ${boxType.shipmentBoxTypeId} is missing weight or weight UOM, skipping package</message><continue/></if>

                <set field="distance_unit" from="dimUom.abbreviation"/>
                <if condition="!(distance_unit in ['cm', 'in', 'ft', 'mm', 'm', 'yd'])">
                    <message>Package ${packageInfo_index} box type ${boxType.shipmentBoxTypeId} dimension unit is '${distance_unit}', must be one of: 'cm', 'in', 'ft', 'mm', 'm', 'yd'; skipping package</message><continue/></if>
                <set field="mass_unit" from="weightUom.abbreviation"/>
                <if condition="!(mass_unit in ['g', 'oz', 'lb', 'kg'])">
                    <message>Package ${packageInfo_index} box type ${boxType.shipmentBoxTypeId} weight unit is '${mass_unit}', must be one of: 'g', 'oz', 'lb', 'kg'; skipping package</message><continue/></if>

                <set field="parcel" from="[length:boxType.boxLength, width:boxType.boxWidth, height:boxType.boxHeight,
                            distance_unit:distance_unit, weight:weight, mass_unit:mass_unit, template:boxType.gatewayBoxId]"/>
                <set field="parcels" from="[parcel]"/>

                <!-- add extra.insurance if applicable -->
                <service-call name="mantle.shipment.CarrierServices.get#GeneralPackageRequiresInsurance" out-map="insuranceReqOut" out-map-add-to-existing="false"
                        in-map="[quantityByProductId:packageInfo.quantityByProductId, currencyUomId:currencyUomId,
                            productStoreId:productStoreId, vendorPartyId:vendorPartyId]"/>
                <log message="rates ${productStoreId} ${packageInfo.quantityByProductId} ${insuranceReqOut}"/>
                <if condition="insuranceReqOut.insuranceRequired &amp;&amp; insuranceReqOut.packageTotalCost">
                    <!-- parcel.extra.insurance.amount, currency, provider, content -->
                    <!-- FUTURE: support for provider field, initial implementation for Shippo's Shipsurance where no provider is specified
                        see: https://goshippo.com/docs/insurance/?_ga=2.131195663.1849014295.1614148616-176427592.1614050676 -->
                    <set field="parcel.extra" from="[insurance:[amount:insuranceReqOut.packageTotalCost, currency:currencyUomId,
                            content:insuranceReqOut.contentDescription]]"/>
                </if>

                <!-- assemble the full request Map -->
                <set field="requestMap" from="[address_from:address_from, address_to:address_to,
                    parcels:parcels, carrier_accounts:carrier_accounts, async:false, extra:[bypass_address_validation:true]]"/>
                <!-- NOTE: any way to pass servicelevel_token(s) to limit in advance? for now just filtering after -->

                <script>requestMapList.add(requestMap); requestPackageIdList.add(packageInfo.shipmentPackageSeqId)</script>
            </iterate>
            <if condition="!requestMapList"><set field="shippingRateInfoList" from="[]"/><return/></if>

            <!-- let request#ShipmentRateInfoInternal do the actual requests to Shippo and assemble the results -->
            <service-call name="mantle.shippo.ShippoServices.request#ShipmentRateInfoInternal" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="get" noun="ShippingRate">
        <implements service="mantle.shipment.CarrierServices.get#ShippingRate"/>
        <actions>
            <!-- TODO FUTURE: get rate from Shippo and save ID, change request#ShippingLabels to do transaction based on rate if set -->
        </actions>
    </service>

    <service verb="request" noun="ShipmentRateInfoInternal">
        <in-parameters>
            <parameter name="apiToken" required="true"/>
            <parameter name="requestMapList" type="List" required="true"/>
            <parameter name="requestPackageIdList" type="List"/>
            <parameter name="carrierMethodByServiceLevel" type="Map" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="shippingRateInfoList" type="List"/>
            <parameter name="rateInfoByServiceLevelByPackage" type="Map"/>
        </out-parameters>
        <actions>
            <!-- do HTTP requests async with a Future -->
            <set field="restClientFutureList" from="[]"/>
            <iterate list="requestMapList" entry="requestMap">
                <log level="info" message="Shippo bulk rates request:\n${requestMap}"/>
                <script><![CDATA[
                    org.moqui.util.RestClient restClient = ec.service.rest().method(org.moqui.util.RestClient.POST)
                            .addHeader("Authorization", "ShippoToken ${apiToken}")
                            .addHeader("Shippo-API-Version", "2018-02-08")
                            .addHeader("Content-Type", "application/json").jsonObject(requestMap)
                    restClient.uri().protocol("https").host("api.goshippo.com").port(443).path("shipments").build()

                    restClientFutureList.add(restClient.callFuture())
                ]]></script>
            </iterate>

            <!-- iterate through Futures and get responses -->
            <set field="rateInfoByServiceLevel" from="[:]"/>
            <set field="rateInfoByServiceLevelByPackage" from="[:]"/>
            <set field="curFutureIndex" from="0"/>
            <iterate list="restClientFutureList" entry="restClientFuture">
                <script><![CDATA[
                    org.moqui.util.RestClient.RestResponse restResponse = restClientFuture.get()
                    if (restResponse.statusCode < 200 || restResponse.statusCode >= 300) {
                        // based on code in Shippo Java client will return error message in plain text body
                        String errMsg = restResponse.text()
                        ec.logger.error("Shippo error response (${restResponse.statusCode}): ${errMsg}")
                        ec.message.addMessage("Shippo API error")
                        ec.message.addMessage(errMsg)
                        return
                    }
                    responseMap = restResponse.jsonObject()
                ]]></script>

                <!-- <log level="warn" message="Shippo bulk rates response: ${restResponse.text()}"/> -->

                <!-- show messages -->
                <if condition="responseMap.messages"><iterate list="responseMap.messages" entry="messageObj">
                    <message>(${messageObj.source}:${messageObj.code}) ${messageObj.text}</message></iterate></if>

                <if condition="responseMap.status != 'SUCCESS'">
                    <message>Shippo label status ${responseMap.status} for package</message></if>

                <!-- find the rates matching the servicelevel_token -->
                <!-- get the lowest rate per service level per package (ie per request) -->
                <set field="curRateInfoByServiceLevel" from="[:]"/>
                <iterate list="responseMap.rates" entry="rateMap">
                    <set field="serviceLevelToken" from="rateMap?.servicelevel?.token"/>
                    <if condition="!serviceLevelToken"><continue/></if>
                    <set field="carrierMethod" from="carrierMethodByServiceLevel.get(serviceLevelToken)"/>
                    <if condition="carrierMethod != null">
                        <set field="rateInfo" from="curRateInfoByServiceLevel.get(serviceLevelToken)"/>
                        <set field="rateAmount" from="rateMap.amount as BigDecimal"/>
                        <!-- add a rate info Map if none found or current rateAmount is lower -->
                        <if condition="rateInfo == null || rateAmount &lt; rateInfo.shippingTotal">
                            <script>curRateInfoByServiceLevel.put(serviceLevelToken, [carrierPartyId:carrierMethod.carrierPartyId,
                                    shipmentMethodEnumId:carrierMethod.shipmentMethodEnumId, shippingTotal:rateAmount,
                                    currency:rateMap.currency, days:rateMap.estimated_days, durationTerms:rateMap.duration_terms,
                                    serviceName:rateMap.servicelevel.name, carrierImageUrl:rateMap.provider_image_75,
                                    shippoObjectId:rateMap.object_id])</script>
                        </if>
                    </if>
                </iterate>

                <!-- if we got a shipmentPackageSeqId also add to Map by package -->
                <set field="shipmentPackageSeqId" from="requestPackageIdList?.get(curFutureIndex)"/>
                <script>if (shipmentPackageSeqId) rateInfoByServiceLevelByPackage.put(shipmentPackageSeqId, curRateInfoByServiceLevel)</script>
                <set field="curFutureIndex" from="curFutureIndex + 1"/>

                <!-- add lowest rate per package to the overall rate (only applicable for multiple packages) -->
                <!-- ie merge curRateInfoByServiceLevel into rateInfoByServiceLevel by adding shippingTotal -->
                <iterate list="curRateInfoByServiceLevel" entry="curRateInfo" key="serviceLevelToken">
                    <set field="rateInfo" from="rateInfoByServiceLevel.get(serviceLevelToken)"/>
                    <!-- <log level="info" message="${serviceLevelToken} cur ${curRateInfo}\n existing ${rateInfo}"/> -->
                    <if condition="rateInfo != null"><then>
                        <!-- use a clone of the rate info Map so original is not modified -->
                        <set field="newRateInfo" from="new HashMap(rateInfo)"/>
                        <set field="newRateInfo.shippingTotal" from="(newRateInfo.shippingTotal ?: 0.0) + (curRateInfo.shippingTotal ?: 0.0)"/>
                        <script>newRateInfo.remove(shippoObjectId)</script>
                        <script>rateInfoByServiceLevel.put(serviceLevelToken, newRateInfo)</script>
                        <!-- <log level="info" message="${serviceLevelToken} new ${newRateInfo}"/> -->
                    </then><else>
                        <script>rateInfoByServiceLevel.put(serviceLevelToken, curRateInfo)</script>
                    </else></if>
                </iterate>
            </iterate>
            <!--
            <iterate list="rateInfoByServiceLevelByPackage" entry="logRateInfoByServiceLevel" key="logPackageSeqId">
                <iterate list="logRateInfoByServiceLevel" entry="logRateInfo" key="logServiceLevel">
                    <log level="warn" message="${logPackageSeqId}:${logServiceLevel}:${logRateInfo}"/></iterate></iterate>
            -->

            <!-- the final list is the combined map values -->
            <set field="shippingRateInfoList" from="new ArrayList(rateInfoByServiceLevel.values())"/>
        </actions>
    </service>
    <service verb="make" noun="ShipmentInfo">
        <in-parameters>
            <parameter name="shipmentId" required="true"/>
            <parameter name="shipmentRouteSegmentSeqId" required="true"/>
            <parameter name="shippingGatewayConfigId" required="true"/>
            <parameter name="shipment" type="EntityValue" required="true"/>
            <parameter name="routeSegment" type="EntityValue" required="true"/>
            <parameter name="shipmentMethodEnumId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="productStoreId"/>
            <parameter name="overrideName"/>
            <parameter name="overrideCompany"/>

            <parameter name="address_from" type="Object"/>
            <parameter name="address_return" type="Object"/>
            <parameter name="address_to" type="Object"/>
            <parameter name="carrier_account"/>
            <parameter name="servicelevel_token"/>
        </out-parameters>
        <actions>
            <set field="fromPartyId" from="shipment.fromPartyId"/>
            <set field="toPartyId" from="shipment.toPartyId"/>
            <set field="carrierPartyId" from="routeSegment.carrierPartyId"/>
            <set field="shipmentMethodEnumId" from="shipmentMethodEnumId ?: routeSegment.shipmentMethodEnumId"/>

            <!-- find a productStoreId -->
            <set field="productStoreId" from="shipment.productStoreId"/>
            <if condition="!productStoreId">
                <entity-find entity-name="mantle.shipment.ShipmentItemSource" list="shipmentItemSourceList" distinct="true">
                    <econdition field-name="shipmentId"/><select-field field-name="orderId"/></entity-find>
                <set field="orderIdSet" from="new HashSet(shipmentItemSourceList*.orderId)"/>
                <if condition="orderIdSet">
                    <entity-find entity-name="mantle.order.OrderHeader" list="orderHeaderList" distinct="true">
                        <econdition field-name="orderId" operator="in" from="orderIdSet"/>
                        <econdition field-name="productStoreId" operator="is-not-null"/>
                        <select-field field-name="productStoreId"/>
                    </entity-find>
                    <set field="productStoreIdSet" from="new HashSet(orderHeaderList*.productStoreId)"/>
                    <set field="productStoreId" from="productStoreIdSet ? productStoreIdSet.first() : null"/>
                    <if condition="productStoreIdSet.size() &gt; 1">
                        <message type="warning">For shipment ${shipmentId} found multiple ProductStores ${productStoreIdSet}, using ${productStoreId}</message>
                    </if>
                </if>
            </if>

            <!-- If there is a ProductStore associated with the Shipment set name and/or company from it -->
            <set field="overrideName" from="null"/>
            <set field="overrideCompany" from="null"/>
            <if condition="productStoreId">
                <!-- NOTE: cached so do separately -->
                <entity-find entity-name="mantle.product.store.ProductStoreSetting" list="nameSettingList" cache="true">
                    <date-filter/><econdition field-name="productStoreId"/>
                    <econdition field-name="settingTypeEnumId" value="PsstShipLabelName"/>
                    <order-by field-name="-fromDate"/>
                </entity-find>
                <set field="overrideName" from="nameSettingList ? nameSettingList[0].settingValue : null"/>
                <entity-find entity-name="mantle.product.store.ProductStoreSetting" list="companySettingList" cache="true">
                    <date-filter/><econdition field-name="productStoreId"/>
                    <econdition field-name="settingTypeEnumId" value="PsstShipLabelCompany"/>
                    <order-by field-name="-fromDate"/>
                </entity-find>
                <set field="overrideCompany" from="companySettingList ? companySettingList[0].settingValue : null"/>
            </if>

            <!-- address_from -->
            <set field="originPostalContactMechId" from="routeSegment.originPostalContactMechId"/>
            <if condition="!originPostalContactMechId &amp;&amp; routeSegment.originFacilityId">
                <service-call name="mantle.facility.ContactServices.get#FacilityDefaultShipOrigin" out-map="facOriginOut"
                        in-map="[facilityId:routeSegment.originFacilityId]"/>
                <if condition="facOriginOut.postalContactMechId">
                    <set field="originPostalContactMechId" from="facOriginOut.postalContactMechId"/>
                    <set field="routeSegment.originPostalContactMechId" from="originPostalContactMechId"/>
                    <entity-update value-field="routeSegment"/>
                </if>
            </if>
            <if condition="originPostalContactMechId"><then>
                <entity-find-one entity-name="mantle.party.contact.PostalAddress" value-field="originPostalAddress">
                    <field-map field-name="contactMechId" from="originPostalContactMechId"/></entity-find-one>
                <if condition="!originPostalAddress.shipGatewayAddressId">
                    <service-call name="mantle.shippo.ShippoServices.validate#PostalAddress" out-map="fromValidateOut"
                            in-map="[contactMechId:originPostalContactMechId, partyId:fromPartyId, facilityId:routeSegment.originFacilityId,
                                shippingGatewayConfigId:shippingGatewayConfigId]"/>
                    <set field="originPostalContactMechId" from="fromValidateOut.contactMechId"/>
                    <set field="routeSegment.originPostalContactMechId" from="originPostalContactMechId"/>
                    <entity-update value-field="routeSegment"/>

                    <entity-find-one entity-name="mantle.party.contact.PostalAddress" value-field="originPostalAddress">
                        <field-map field-name="contactMechId" from="originPostalContactMechId"/></entity-find-one>
                </if>

                <!-- now get origin address -->
                <if condition="overrideName || overrideCompany"><then>
                    <service-call name="mantle.shippo.ShippoServices.get#AddressMap" out-map="originAddrOut"
                            in-map="[postalAddress:originPostalAddress, partyId:fromPartyId, isOrigin:true]"/>
                    <set field="address_from" from="originAddrOut.addressMap"/>
                    <set field="address_from.name" from="overrideName"/>
                    <set field="address_from.company" from="overrideCompany"/>
                </then><else>
                    <entity-find-one entity-name="mantle.party.contact.ContactMech" value-field="originContactMech">
                        <field-map field-name="contactMechId" from="originPostalContactMechId"/></entity-find-one>
                    <if condition="originPostalAddress.shipGatewayAddressId &amp;&amp; originContactMech.trustLevelEnumId in ['CmtlValid', 'CmtlVerified']"><then>
                        <set field="address_from" from="originPostalAddress.shipGatewayAddressId"/>
                    </then><else>
                        <service-call name="mantle.shippo.ShippoServices.get#AddressMap" out-map="originAddrOut"
                                in-map="[postalAddress:originPostalAddress, partyId:fromPartyId, isOrigin:true]"/>
                        <set field="address_from" from="originAddrOut.addressMap"/>
                    </else></if>
                </else></if>
            </then><else>
                <message error="true">No origin address set on Shipment Route Segment ${shipmentId}:${shipmentRouteSegmentSeqId}</message>
            </else></if>

            <!-- address_return - from routeSegment.returnPostalContactMechId or ProductStore.returnPostalContactMechId -->
            <set field="address_return" from="null"/>
            <set field="returnPostalContactMechId" from="routeSegment.returnPostalContactMechId"/>
            <if condition="!returnPostalContactMechId &amp;&amp; productStoreId">
                <entity-find-one entity-name="mantle.product.store.ProductStore" value-field="productStore"/>
                <set field="returnPostalContactMechId" from="productStore?.returnPostalContactMechId"/>
            </if>
            <if condition="returnPostalContactMechId">
                <entity-find-one entity-name="mantle.party.contact.PostalAddress" value-field="returnPostalAddress">
                    <field-map field-name="contactMechId" from="returnPostalContactMechId"/></entity-find-one>

                <!-- now get return address -->
                <service-call name="mantle.shippo.ShippoServices.get#AddressMap" out-map="returnAddrOut"
                        in-map="[postalAddress:returnPostalAddress, partyId:fromPartyId, isOrigin:false]"/>
                <set field="address_return" from="returnAddrOut.addressMap"/>
                <if condition="overrideName"><set field="address_return.name" from="overrideName"/></if>
                <if condition="overrideCompany"><set field="address_return.company" from="overrideCompany"/></if>
            </if>

            <!-- address_to -->
            <set field="destPostalContactMechId" from="routeSegment.destPostalContactMechId"/>
            <if condition="!destPostalContactMechId &amp;&amp; routeSegment.destinationFacilityId">
                <service-call name="mantle.facility.ContactServices.get#FacilityDefaultShipDest" out-map="facOriginOut"
                        in-map="[facilityId:routeSegment.destinationFacilityId]"/>
                <if condition="facOriginOut.postalContactMechId">
                    <set field="destPostalContactMechId" from="facOriginOut.postalContactMechId"/>
                    <set field="routeSegment.destPostalContactMechId" from="destPostalContactMechId"/>
                    <entity-update value-field="routeSegment"/>
                </if>
            </if>
            <if condition="destPostalContactMechId"><then>
                <entity-find-one entity-name="mantle.party.contact.PostalAddress" value-field="destPostalAddress">
                    <field-map field-name="contactMechId" from="destPostalContactMechId"/></entity-find-one>
                <if condition="!destPostalAddress.shipGatewayAddressId">
                    <service-call name="mantle.shippo.ShippoServices.validate#PostalAddress" out-map="toValidateOut"
                            in-map="[contactMechId:destPostalContactMechId, partyId:toPartyId, shippingGatewayConfigId:shippingGatewayConfigId]"/>
                    <set field="destPostalContactMechId" from="toValidateOut.contactMechId"/>
                    <set field="routeSegment.destPostalContactMechId" from="destPostalContactMechId"/>
                    <entity-update value-field="routeSegment"/>

                    <entity-find-one entity-name="mantle.party.contact.PostalAddress" value-field="destPostalAddress">
                        <field-map field-name="contactMechId" from="destPostalContactMechId"/></entity-find-one>
                </if>

                <entity-find-one entity-name="mantle.party.contact.ContactMech" value-field="destContactMech">
                    <field-map field-name="contactMechId" from="destPostalContactMechId"/></entity-find-one>
                <!-- NOTE: only use destPostalAddress.shipGatewayAddressId as object ID for address is CmtlValid or CmtlVerified
                    and if has telecomContactMechId, if no phone want to default to other party's ship dest phone so label can be issued -->
                <if condition="destPostalAddress.shipGatewayAddressId &amp;&amp; destPostalAddress.telecomContactMechId &amp;&amp;
                        destContactMech.trustLevelEnumId in ['CmtlValid', 'CmtlVerified']"><then>
                    <set field="address_to" from="destPostalAddress.shipGatewayAddressId"/>
                </then><else>
                    <service-call name="mantle.shippo.ShippoServices.get#AddressMap" out-map="destAddrOut"
                            in-map="[postalAddress:destPostalAddress, partyId:toPartyId, otherPartyId:fromPartyId, isOrigin:false]"/>
                    <set field="address_to" from="destAddrOut.addressMap"/>
                </else></if>
            </then><else>
                <message error="true">No destination address set on Shipment Route Segment ${shipmentId}:${shipmentRouteSegmentSeqId}</message>
            </else></if>

            <!-- carrier_account, servicelevel_token -->
            <entity-find-one entity-name="mantle.shipment.carrier.ShippingGatewayCarrier" value-field="gatewayCarrier"/>
            <set field="carrier_account" from="gatewayCarrier?.gatewayAccountId"/>
            <if condition="!carrier_account"><message error="true">No Shippo account ID found for carrier ${carrierPartyId} in gateway ${shippingGatewayConfigId}</message></if>
            <entity-find-one entity-name="mantle.shipment.carrier.CarrierShipmentMethod" value-field="carrierShipmentMethod"/>
            <set field="servicelevel_token" from="carrierShipmentMethod?.gatewayServiceCode"/>
            <if condition="!servicelevel_token"><message error="true">No Shippo service level code found for carrier ${carrierPartyId} method ${shipmentMethodEnumId}</message></if>
        </actions>
    </service>
    <service verb="make" noun="ShipmentPackageInfo">
        <in-parameters>
            <parameter name="packageRouteSeg" type="EntityValue" required="true"/>
            <parameter name="routeSegment" type="EntityValue" required="true"/>
            <parameter name="shipment" type="EntityValue" required="true"/>
            <parameter name="getReturnLabels" type="Boolean" required="true"/>
            <parameter name="productStoreId"/>

            <parameter name="address_from" type="Object"/>
            <parameter name="address_return" type="Object"/>
            <parameter name="address_to" type="Object"/>
        </in-parameters>
        <out-parameters>
            <parameter name="skipPackage" type="Boolean"/>
            <parameter name="parcel" type="Map"/>
            <parameter name="extraMap" type="Map"/>
            <parameter name="shipmentMap" type="Map"/>
            <parameter name="insuredAmount" type="BigDecimal"/>
        </out-parameters>
        <actions>
            <set field="shipmentId" from="packageRouteSeg.shipmentId"/>
            <set field="shipmentRouteSegmentSeqId" from="packageRouteSeg.shipmentRouteSegmentSeqId"/>
            <set field="shipmentPackageSeqId" from="packageRouteSeg.shipmentPackageSeqId"/>

            <set field="carrierPartyId" from="routeSegment.carrierPartyId"/>

            <set field="skipPackage" from="false"/>
            <set field="shipmentPackageSeqId" from="packageRouteSeg.shipmentPackageSeqId"/>
            <if condition="getReturnLabels"><then>
                <if condition="packageRouteSeg.returnGatewayLabelId || packageRouteSeg.returnLabelUrl">
                    <message type="warning">Package ${shipmentPackageSeqId} in route segment ${shipmentRouteSegmentSeqId} already has return label ${packageRouteSeg.returnGatewayLabelId}, skipping package</message>
                    <set field="skipPackage" from="true"/>
                    <return/>
                </if>
            </then><else>
                <if condition="packageRouteSeg.gatewayLabelId || packageRouteSeg.labelUrl">
                    <message type="warning">Package ${shipmentPackageSeqId} in route segment ${shipmentRouteSegmentSeqId} already has label ${packageRouteSeg.gatewayLabelId}, skipping package</message>
                    <set field="skipPackage" from="true"/>
                    <return/>
                </if>
            </else></if>

            <entity-find-one entity-name="mantle.shipment.ShipmentPackage" value-field="shipmentPackage"/>

            <!-- ===== Parcel Map ===== -->

            <set field="boxType" from="shipmentPackage.boxType"/>
            <if condition="boxType == null"><message type="warning">Package ${shipmentPackageSeqId} has no box type, skipping</message>
                <set field="skipPackage" from="true"/><return/></if>

            <set field="dimUom" from="boxType.dimensionUom"/>
            <if condition="!boxType.boxLength || !boxType.boxWidth || !boxType.boxHeight || dimUom == null">
                <message type="warning">Box type ${boxType.shipmentBoxTypeId} is missing dimensions (length, width, height) or dimension UOM, skipping package</message>
                <set field="skipPackage" from="true"/><return/>
            </if>
            <set field="weightUom" from="shipmentPackage.weightUom ?: boxType.weightUom"/>
            <set field="weight" from="shipmentPackage.weight ?: boxType.defaultGrossWeight"/>
            <if condition="!weight || weightUom == null">
                <message type="warning">Package ${shipmentPackageSeqId} box type ${boxType.shipmentBoxTypeId} is missing weight or weight UOM, skipping package</message>
                <set field="skipPackage" from="true"/><return/>
            </if>

            <set field="distance_unit" from="dimUom.abbreviation"/>
            <if condition="!(distance_unit in ['cm', 'in', 'ft', 'mm', 'm', 'yd'])">
                <message type="warning">Package ${shipmentPackageSeqId} box type ${boxType.shipmentBoxTypeId} dimension unit is '${distance_unit}', must be one of: 'cm', 'in', 'ft', 'mm', 'm', 'yd'; skipping package</message>
                <set field="skipPackage" from="true"/><return/>
            </if>
            <set field="mass_unit" from="weightUom.abbreviation"/>
            <if condition="!(mass_unit in ['g', 'oz', 'lb', 'kg'])">
                <message type="warning">Package ${shipmentPackageSeqId} box type ${boxType.shipmentBoxTypeId} weight unit is '${mass_unit}', must be one of: 'g', 'oz', 'lb', 'kg'; skipping package</message>
                <set field="skipPackage" from="true"/><return/>
            </if>

            <set field="parcel" from="[length:boxType.boxLength, width:boxType.boxWidth, height:boxType.boxHeight,
                        distance_unit:distance_unit, weight:weight, mass_unit:mass_unit, template:boxType.gatewayBoxId]"/>

            <!-- add parcel.extra.insurance if applicable -->
            <service-call name="mantle.shipment.CarrierServices.get#ShipmentPackageRequiresInsurance" out-map="insuranceReqOut" out-map-add-to-existing="false"
                    in-map="[shipmentId:shipmentId, shipmentPackageSeqId:shipmentPackageSeqId, shipment:shipment]"/>
            <if condition="insuranceReqOut.insuranceRequired &amp;&amp; insuranceReqOut.packageTotalCost">
                <set field="insuredAmount" from="insuranceReqOut.packageTotalCost"/>
                <!-- parcel.extra.insurance.amount, currency, provider, content -->
                <!-- FUTURE: support for provider field, initial implementation for Shippo's Shipsurance where no provider is specified
                    see: https://goshippo.com/docs/insurance/?_ga=2.131195663.1849014295.1614148616-176427592.1614050676 -->
                <set field="parcel.extra" from="[insurance:[amount:insuredAmount, currency:(shipment.costUomId ?: 'USD'),
                    content:insuranceReqOut.contentDescription]]"/>
            </if>

            <!-- ===== Shipment Extra Map ===== -->

            <!-- reference_1 with Shipment, Order IDs -->
            <set field="reference1" value="Shipment ${shipmentId}"/>
            <entity-find entity-name="mantle.shipment.ShipmentItemSource" list="shipmentItemSourceList">
                <econdition field-name="shipmentId"/><econdition field-name="orderId" operator="is-not-null"/>
                <select-field field-name="orderId"/>
            </entity-find>
            <set field="orderIdSet" from="shipmentItemSourceList ? new TreeSet(shipmentItemSourceList*.orderId) : null"/>
            <if condition="orderIdSet">
                <!-- if any order has a displayId use that instead -->
                <entity-find entity-name="mantle.order.OrderHeader" list="orderHeaderList">
                    <econdition field-name="orderId" operator="in" from="orderIdSet"/>
                    <econdition field-name="displayId" operator="is-not-null"/>
                    <select-field field-name="orderId,displayId"/>
                </entity-find>
                <iterate list="orderHeaderList" entry="orderHeader">
                    <script>if (orderHeader.displayId) { orderIdSet.remove(orderHeader.orderId); orderIdSet.add(orderHeader.displayId) }</script>
                </iterate>
                <set field="reference1" value="Order ${orderIdSet.join(', ')} ${reference1}"/>
            </if>
            <if condition="reference1.length() &gt; 50"><set field="reference1" from="reference1.substring(0, 50)"/></if>

            <!-- reference_2 with otherPartyOrderId -->
            <set field="reference2" value=""/>
            <if condition="shipment.otherPartyOrderId"><set field="reference2" value="Your Order ${shipment.otherPartyOrderId}"/></if>

            <!-- assemble the extra Map -->
            <set field="extraMap" from="[reference_1:reference1, reference_2:reference2, bypass_address_validation:true, is_return:getReturnLabels]"/>
            <!-- extra.signature_confirmation -->
            <if condition="shipment.signatureRequiredEnumId &amp;&amp; shipment.signatureRequiredEnumId != 'PsrNone'">
                <set field="signatureRequiredEnum" from="shipment.signatureRequiredEnum"/>
                <if condition="signatureRequiredEnum?.enumCode"><then>
                    <set field="extraMap.signature_confirmation" from="signatureRequiredEnum.enumCode"/>
                </then><else>
                    <message type="warning">Shipment ${shipmentId} has signatureRequiredEnumId ${shipment.signatureRequiredEnumId} and Enumeration has no enumCode, not setting Shippo extra.signature_confirmation</message>
                </else></if>
            </if>
            <!-- extra.billing from ProductStoreShippingGateway -->
            <!-- <log level="warn" message="ShipmentPackageInfo ${shipmentId} carrierPartyId ${carrierPartyId} productStoreId ${productStoreId}"/> -->
            <if condition="productStoreId">
                <entity-find-one entity-name="mantle.product.store.ProductStoreShippingGateway" value-field="pssg">
                    <field-map field-name="productStoreId"/><field-map field-name="carrierPartyId"/></entity-find-one>
                <if condition="pssg?.billingType">
                    <set field="extraMap.billing" from="[type:pssg.billingType, account:pssg.billingAccount,
                                zip:pssg.billingZip, country:pssg.billingCountry]"/>
                </if>
            </if>

            <!-- assemble the shipment Map -->
            <!-- NOTE: Shippo returns an error like 'The address_return may not be set when a return_of is specified' if address_return is used, so use address_return if there is one for address_from if getReturnLabels -->
            <if condition="getReturnLabels"><then>
                <if condition="address_return"><then>
                    <set field="shipmentMap" from="[object_purpose:'PURCHASE', address_from:address_return, address_to:address_to, parcels:[parcel], extra:extraMap, async:false]"/>
                </then><else>
                    <set field="shipmentMap" from="[object_purpose:'PURCHASE', address_from:address_from, address_to:address_to, parcels:[parcel], extra:extraMap, async:false]"/>
                </else></if>
            </then><else>
                <set field="shipmentMap" from="[object_purpose:'PURCHASE', address_from:address_from, address_to:address_to, parcels:[parcel], extra:extraMap, async:false]"/>
                <if condition="address_return"><set field="shipmentMap.address_return" from="address_return"/></if>
            </else></if>
        </actions>
    </service>

    <!-- ============================================= -->
    <!-- ========== Shipping Label Services ========== -->
    <!-- ============================================= -->

    <service verb="request" noun="ShippingLabels">
        <!-- see: https://goshippo.com/docs/reference#transactions -->
        <implements service="mantle.shipment.CarrierServices.request#ShippingLabels"/>
        <actions>
            <entity-find-one entity-name="mantle.shipment.carrier.ShippingGatewayOption" value-field="apiTokenOpt">
                <field-map field-name="shippingGatewayConfigId"/><field-map field-name="optionEnumId" value="SgoApiToken"/></entity-find-one>
            <set field="apiToken" from="apiTokenOpt?.optionValue"/>
            <if condition="!apiToken"><log level="warn" message="Shipping gateway ${shippingGatewayConfigId} has no SgoApiToken, not requesting label"/><return/></if>

            <entity-find-one entity-name="mantle.shipment.carrier.ShippingGatewayOption" value-field="labelTypeOpt">
                <field-map field-name="shippingGatewayConfigId"/><field-map field-name="optionEnumId" value="SgoLabelType"/></entity-find-one>
            <set field="label_file_type" from="labelTypeOpt?.optionValue ?: 'PDF'"/>

            <!-- NOTE: lock on Shipment record -->
            <entity-find-one entity-name="mantle.shipment.Shipment" value-field="shipment" for-update="true"/>
            <if condition="shipment == null"><return error="true" message="Shipment not found with ID ${shipmentId}"/></if>
            <entity-find-one entity-name="mantle.shipment.ShipmentRouteSegment" value-field="routeSegment"/>
            <if condition="routeSegment == null"><return error="true" message="Shipment Route Segment not found with ID ${shipmentId}:${shipmentRouteSegmentSeqId}"/></if>

            <set field="hasIssues" from="false"/>
            <set field="fromPartyId" from="shipment.fromPartyId"/>
            <if condition="!fromPartyId"><set field="hasIssues" from="true"/>
                <message type="danger">From party not set on shipment ${shipmentId}</message></if>
            <set field="toPartyId" from="shipment.toPartyId"/>
            <if condition="!toPartyId"><set field="hasIssues" from="true"/>
                <message type="danger">To party not set on shipment ${shipmentId}</message></if>

            <set field="carrierPartyId" from="routeSegment.carrierPartyId"/>
            <if condition="!carrierPartyId || carrierPartyId == '_NA_'"><set field="hasIssues" from="true"/>
                <message type="danger">Carrier not set on shipment ${shipmentId}:${shipmentRouteSegmentSeqId}</message></if>
            <set field="shipmentMethodEnumId" from="shipmentMethodEnumId ?: routeSegment.shipmentMethodEnumId"/>
            <if condition="!shipmentMethodEnumId"><set field="hasIssues" from="true"/>
                <message type="danger">Shipment method not set on shipment ${shipmentId}:${shipmentRouteSegmentSeqId}</message></if>

            <if condition="hasIssues">
                <message type="danger">Issues found, not requesting Shippo labels</message>
                <return/>
            </if>

            <service-call name="mantle.shippo.ShippoServices.make#ShipmentInfo" in-map="context" out-map="context"/>

            <!-- the rest is per package -->
            <!-- TODO: multi-parcel shipments for UPS and FedEx only up to 10 parcels, see https://goshippo.com/docs/multipiece -->
            <entity-find entity-name="mantle.shipment.ShipmentPackageRouteSeg" list="packageRouteSegList">
                <econdition field-name="shipmentId"/><econdition field-name="shipmentRouteSegmentSeqId"/>
                <econdition field-name="shipmentPackageSeqId" ignore-if-empty="true"/>
            </entity-find>

            <set field="futureInsuredAmountList" from="new ArrayList()"/>

            <!-- if FedEx get rates in separate calls and use the lowest price rate ID (for FedEx OneRate support, might apply to others in the future) -->
            <!-- FUTURE: make this configurable for other carriers... and people using non-standard carrier parties with a different ID... -->
            <set field="rateInfoOut" from="null"/>
            <!-- for testing:  || 'USPS'.equalsIgnoreCase(carrierPartyId) -->
            <if condition="'FedEx'.equalsIgnoreCase(carrierPartyId)">
                <set field="requestMapList" from="[]"/>
                <set field="requestPackageIdList" from="[]"/>
                <iterate list="packageRouteSegList" entry="packageRouteSeg">
                    <service-call name="mantle.shippo.ShippoServices.make#ShipmentPackageInfo" in-map="context"
                            out-map="pkgInfoOut" out-map-add-to-existing="false"/>
                    <if condition="pkgInfoOut.skipPackage"><continue/></if>
                    <!-- always add an entry to futureInsuredAmountList, is parallel array to others -->
                    <script>futureInsuredAmountList.add(pkgInfoOut.insuredAmount)</script>

                    <!-- has address_from, address_to, parcels, extra, async -->
                    <set field="requestMap" from="pkgInfoOut.shipmentMap"/>
                    <set field="requestMap.carrier_accounts" from="[carrier_account]"/>

                    <!-- populate requestMapList and requestPackageIdList -->
                    <script>requestMapList.add(requestMap); requestPackageIdList.add(packageRouteSeg.shipmentPackageSeqId)</script>
                </iterate>

                <!-- let request#ShipmentRateInfoInternal do the actual requests to Shippo and assemble the results -->
                <set field="carrierMethodByServiceLevel" from="[(servicelevel_token):[carrierPartyId:carrierPartyId, shipmentMethodEnumId:shipmentMethodEnumId]]"/>
                <service-call name="mantle.shippo.ShippoServices.request#ShipmentRateInfoInternal" in-map="context" out-map="rateInfoOut"/>
            </if>


            <set field="restClientFutureList" from="new ArrayList()"/>
            <set field="futurePackageRouteSegList" from="new ArrayList()"/>
            <iterate list="packageRouteSegList" entry="packageRouteSeg">
                <set field="shipmentPackageSeqId" from="packageRouteSeg.shipmentPackageSeqId"/>
                <set field="requestMap" from="null"/>

                <if condition="rateInfoOut != null">
                    <set field="rateInfo" from="rateInfoOut.rateInfoByServiceLevelByPackage?.get(packageRouteSeg.shipmentPackageSeqId)?.get(servicelevel_token)"/>
                    <if condition="rateInfo?.shippoObjectId"><then>
                        <!-- see: https://goshippo.com/docs/reference#transactions-create -->
                        <!-- if rates were retrieved use instead of shipment, carrier_account, and servicelevel_token -->
                        <set field="requestMap" from="[rate:rateInfo.shippoObjectId, label_file_type:label_file_type, async:false]"/>
                    </then><else>
                        <message type="danger">No rate info returned from Shippo for package ${shipmentId}:${packageRouteSeg.shipmentPackageSeqId} and service level ${servicelevel_token}, falling back to instant create</message>
                    </else></if>
                </if>

                <if condition="requestMap == null">
                    <!-- see: https://goshippo.com/docs/reference#transactions-create-instant -->
                    <service-call name="mantle.shippo.ShippoServices.make#ShipmentPackageInfo" in-map="context"
                            out-map="pkgInfoOut" out-map-add-to-existing="false"/>
                    <if condition="pkgInfoOut.skipPackage"><continue/></if>
                    <!-- always add an entry to futureInsuredAmountList, is parallel array to others -->
                    <script>futureInsuredAmountList.add(pkgInfoOut.insuredAmount)</script>

                    <set field="requestMap" from="[shipment:pkgInfoOut.shipmentMap, carrier_account:carrier_account,
                            servicelevel_token:servicelevel_token, label_file_type:label_file_type, async:false]"/>
                </if>

                <log level="info" message="Shippo transaction shipment ${shipmentId} package ${packageRouteSeg.shipmentPackageSeqId} request:\n${requestMap}"/>

                <script><![CDATA[
                    org.moqui.util.RestClient restClient = ec.service.rest().method(org.moqui.util.RestClient.POST)
                            .addHeader("Authorization", "ShippoToken ${apiToken}")
                            .addHeader("Shippo-API-Version", "2018-02-08")
                            .addHeader("Content-Type", "application/json").jsonObject(requestMap)
                    restClient.uri().protocol("https").host("api.goshippo.com").port(443).path("transactions").build()
                    restClientFutureList.add(restClient.callFuture())
                    futurePackageRouteSegList.add(packageRouteSeg)
                ]]></script>

            </iterate>
            <iterate list="restClientFutureList" entry="restClientFuture">
                <set field="packageRouteSeg" from="futurePackageRouteSegList.get(restClientFuture_index)"/>
                <set field="shipmentPackageSeqId" from="packageRouteSeg.shipmentPackageSeqId"/>
                <set field="rateInfo" from="rateInfoOut != null ? rateInfoOut.rateInfoByServiceLevelByPackage?.get(packageRouteSeg.shipmentPackageSeqId)?.get(servicelevel_token) : null"/>

                <script><![CDATA[
                    org.moqui.util.RestClient.RestResponse restResponse = restClientFuture.get()
                    if (restResponse.statusCode < 200 || restResponse.statusCode >= 300) {
                        // based on code in Shippo Java client will return error message in plain text body
                        String errMsg = restResponse.text()
                        ec.logger.error("Shippo error package ${shipmentId}:${shipmentRouteSegmentSeqId}:${shipmentPackageSeqId} response (${restResponse.statusCode}): ${errMsg}")
                        ec.message.addMessage("Shippo API error for package ${shipmentPackageSeqId}")
                        ec.message.addMessage(errMsg)
                        if (errMsg.length() > 255) errMsg = errMsg.substring(0, 255)
                        packageRouteSeg.gatewayMessage = errMsg
                        packageRouteSeg.update()
                        continue
                    }
                    responseMap = restResponse.jsonObject()
                ]]></script>

                <!-- <log level="warn" message="Shippo transaction shipment ${shipmentId} response: ${responseMap}"/> -->

                <!-- show messages -->
                <set field="gatewayMessage" value=""/>
                <if condition="responseMap.messages">
                    <iterate list="responseMap.messages" entry="messageObj">
                        <message>(${messageObj.source}:${messageObj.code}) ${messageObj.text}</message>
                        <set field="gatewayMessage" value="${gatewayMessage}(${messageObj.source}:${messageObj.code}) ${messageObj.text} "/>
                    </iterate>
                    <if condition="gatewayMessage.length() &gt; 255"><set field="gatewayMessage" from="gatewayMessage.substring(0,255)"/></if>
                    <if condition="getReturnLabels"><then>
                        <set field="packageRouteSeg.returnGatewayMessage" from="gatewayMessage"/>
                    </then><else>
                        <set field="packageRouteSeg.gatewayMessage" from="gatewayMessage"/>
                    </else></if>
                </if>
                <!-- always save results, whatever we got back -->
                <if condition="getReturnLabels"><then>
                    <set field="packageRouteSeg.returnGatewayStatus" from="responseMap.status"/>
                    <set field="packageRouteSeg.returnGatewayLabelId" from="responseMap.object_id"/>
                    <set field="packageRouteSeg.returnGatewayRateId" from="rateInfo != null ? rateInfo.shippoObjectId : responseMap.rate?.object_id"/>
                    <set field="packageRouteSeg.returnEstimatedAmount" from="rateInfo != null ? rateInfo.shippingTotal as BigDecimal : responseMap.rate?.amount as BigDecimal"/>
                    <set field="packageRouteSeg.returnBaseAmount" from="packageRouteSeg.returnEstimatedAmount"/>
                    <set field="packageRouteSeg.returnTrackingStatusEnumId" value="ShTsUnknown"/>
                    <set field="packageRouteSeg.returnTrackingCode" from="responseMap.tracking_number"/>
                    <set field="packageRouteSeg.returnTrackingUrl" from="responseMap.tracking_url_provider"/>
                    <set field="packageRouteSeg.returnLabelDate" from="ec.l10n.parseTimestamp(responseMap.object_created, 'yyyy-MM-dd\'T\'HH:mm:ss.SSSZ')"/>
                    <set field="packageRouteSeg.returnLabelUrl" from="responseMap.label_url"/>
                </then><else>
                    <set field="packageRouteSeg.gatewayStatus" from="responseMap.status"/>
                    <set field="packageRouteSeg.gatewayLabelId" from="responseMap.object_id"/>
                    <set field="packageRouteSeg.gatewayRateId" from="rateInfo != null ? rateInfo.shippoObjectId : responseMap.rate?.object_id"/>
                    <set field="packageRouteSeg.estimatedAmount" from="rateInfo != null ? rateInfo.shippingTotal as BigDecimal : responseMap.rate?.amount as BigDecimal"/>
                    <set field="packageRouteSeg.baseAmount" from="packageRouteSeg.estimatedAmount"/>
                    <set field="packageRouteSeg.trackingStatusEnumId" value="ShTsUnknown"/>
                    <set field="packageRouteSeg.trackingCode" from="responseMap.tracking_number"/>
                    <set field="packageRouteSeg.trackingUrl" from="responseMap.tracking_url_provider"/>
                    <set field="packageRouteSeg.labelDate" from="ec.l10n.parseTimestamp(responseMap.object_created, 'yyyy-MM-dd\'T\'HH:mm:ss.SSSZ')"/>
                    <set field="packageRouteSeg.labelUrl" from="responseMap.label_url"/>

                    <set field="insuredAmount" from="futureInsuredAmountList.get(restClientFuture_index)"/>
                    <if condition="insuredAmount">
                        <entity-find-one entity-name="mantle.product.store.ProductStoreShippingGateway" value-field="pssg">
                            <field-map field-name="productStoreId"/><field-map field-name="carrierPartyId"/></entity-find-one>
                        <set field="packageRouteSeg.insuredAmount" from="insuredAmount"/>
                        <if condition="pssg?.insurancePercent">
                            <set field="packageRouteSeg.insuranceAmount"
                                    from="new BigDecimal(pssg.insurancePercent).multiply(insuredAmount).divide(100.0, 2, BigDecimal.ROUND_HALF_UP)"/>
                        </if>
                    </if>
                </else></if>
                <entity-update value-field="packageRouteSeg"/>

                <if condition="responseMap.status != 'SUCCESS'">
                    <message>Shippo label status ${responseMap.status} for package ${shipmentPackageSeqId}</message></if>
            </iterate>
        </actions>
    </service>

    <service verb="refund" noun="ShippingLabels">
        <implements service="mantle.shipment.CarrierServices.refund#ShippingLabels"/>
        <actions>
            <entity-find-one entity-name="mantle.shipment.carrier.ShippingGatewayOption" value-field="apiTokenOpt">
                <field-map field-name="shippingGatewayConfigId"/><field-map field-name="optionEnumId" value="SgoApiToken"/></entity-find-one>
            <set field="apiToken" from="apiTokenOpt?.optionValue"/>
            <if condition="!apiToken"><log level="warn" message="Shipping gateway ${shippingGatewayConfigId} has no SgoApiToken, not voiding/refunding label"/><return/></if>

            <entity-find entity-name="mantle.shipment.ShipmentPackageRouteSeg" list="packageRouteSegList">
                <econdition field-name="shipmentId"/><econdition field-name="shipmentRouteSegmentSeqId"/>
                <econdition field-name="shipmentPackageSeqId" ignore-if-empty="true"/>
            </entity-find>
            <iterate list="packageRouteSegList" entry="packageRouteSeg">
                <if condition="!packageRouteSeg.gatewayLabelId"><message>Package ${shipmentPackageSeqId} in route segment ${shipmentRouteSegmentSeqId} has no Shippo label, skipping package</message><continue/></if>
                <if condition="packageRouteSeg.gatewayRefundId"><message>Package ${shipmentPackageSeqId} in route segment ${shipmentRouteSegmentSeqId} Shippo label ${packageRouteSeg.gatewayLabelId} already has refund ${packageRouteSeg.gatewayRefundId}, skipping package</message><continue/></if>

                <set field="requestMap" from="[transaction:packageRouteSeg.gatewayLabelId]"/>
                <!-- <log level="warn" message="Shippo refund shipment ${shipmentId} request:\n${requestMap}"/> -->

                <script><![CDATA[
                    org.moqui.util.RestClient restClient = ec.service.rest().method(org.moqui.util.RestClient.POST)
                            .addHeader("Authorization", "ShippoToken ${apiToken}")
                            .addHeader("Shippo-API-Version", "2018-02-08")
                            .addHeader("Content-Type", "application/json").jsonObject(requestMap)
                    restClient.uri().protocol("https").host("api.goshippo.com").port(443).path("refunds").build()
                    org.moqui.util.RestClient.RestResponse restResponse = restClient.call()
                    if (restResponse.statusCode < 200 || restResponse.statusCode >= 300) {
                        // based on code in Shippo Java client will return error message in plain text body
                        String errMsg = restResponse.text()
                        ec.logger.error("Shippo error package ${shipmentId}:${shipmentRouteSegmentSeqId}:${shipmentPackageSeqId} response (${restResponse.statusCode}): ${errMsg}")
                        ec.message.addMessage("Shippo API error for package ${shipmentPackageSeqId}")
                        ec.message.addMessage(errMsg)
                        continue
                    }
                    responseMap = restResponse.jsonObject()
                ]]></script>

                <!-- <log level="warn" message="Shippo refund shipment ${shipmentId} response: ${responseMap}"/> -->

                <!-- show messages -->
                <if condition="responseMap.messages"><iterate list="responseMap.messages" entry="messageObj">
                    <message>(${messageObj.source}:${messageObj.code}) ${messageObj.text}</message></iterate></if>
                <!-- always save results, whatever we got back -->
                <set field="packageRouteSeg.gatewayRefundStatus" from="responseMap.status"/>
                <set field="packageRouteSeg.gatewayRefundId" from="responseMap.object_id"/>
                <entity-update value-field="packageRouteSeg"/>

                <if condition="responseMap.status != 'SUCCESS'">
                    <message>Shippo refund status ${responseMap.status} for package ${shipmentPackageSeqId}</message></if>
            </iterate>
        </actions>
    </service>
    <service verb="track" noun="ShippingLabels">
        <implements service="mantle.shipment.CarrierServices.track#ShippingLabels"/>
        <actions>
            <entity-find-one entity-name="mantle.shipment.carrier.ShippingGatewayOption" value-field="apiTokenOpt">
                <field-map field-name="shippingGatewayConfigId"/><field-map field-name="optionEnumId" value="SgoApiToken"/></entity-find-one>
            <set field="apiToken" from="apiTokenOpt?.optionValue"/>
            <if condition="!apiToken"><log level="warn" message="Shipping gateway ${shippingGatewayConfigId} has no SgoApiToken, not tracking shipment"/><return/></if>

            <entity-find entity-name="mantle.shipment.ShipmentPackageRouteSeg" list="packageRouteSegList">
                <econdition field-name="shipmentId"/><econdition field-name="shipmentRouteSegmentSeqId"/>
                <econdition field-name="shipmentPackageSeqId" ignore-if-empty="true"/>
            </entity-find>
            <iterate list="packageRouteSegList" entry="packageRouteSeg">
                <if condition="!packageRouteSeg.gatewayLabelId"><message>Package ${shipmentPackageSeqId} in route segment ${shipmentRouteSegmentSeqId} has no Shippo label, skipping package</message><continue/></if>

                <script><![CDATA[
                    org.moqui.util.RestClient restClient = ec.service.rest().method(org.moqui.util.RestClient.GET)
                            .addHeader("Authorization", "ShippoToken ${apiToken}")
                            .addHeader("Shippo-API-Version", "2018-02-08")
                            .addHeader("Content-Type", "application/json")
                    restClient.uri().protocol("https").host("api.goshippo.com").port(443).path("transactions").path((String) packageRouteSeg.gatewayLabelId).build()
                    org.moqui.util.RestClient.RestResponse restResponse = restClient.call()
                    if (restResponse.statusCode < 200 || restResponse.statusCode >= 300) {
                        // based on code in Shippo Java client will return error message in plain text body
                        String errMsg = restResponse.text()
                        ec.logger.error("Shippo error package ${shipmentId}:${shipmentRouteSegmentSeqId}:${shipmentPackageSeqId} response (${restResponse.statusCode}): ${errMsg}")
                        ec.message.addMessage("Shippo API error for package ${shipmentPackageSeqId}")
                        ec.message.addMessage(errMsg)
                        continue
                    }
                    responseMap = restResponse.jsonObject()
                ]]></script>

                <!-- <log level="warn" message="Shippo refund shipment ${shipmentId} response: ${responseMap}"/> -->

                <!-- show messages -->
                <if condition="responseMap.messages"><iterate list="responseMap.messages" entry="messageObj">
                    <message>(${messageObj.source}:${messageObj.code}) ${messageObj.text}</message></iterate></if>
                <!-- check the tracking_number, warn and update if needed -->
                <if condition="responseMap.tracking_number != packageRouteSeg.trackingCode">
                    <message>Tracking number from Shippo ${responseMap.tracking_number} did not match locally stored number ${packageRouteSeg.trackingCode}, updated local to match</message>
                    <set field="packageRouteSeg.trackingCode" from="responseMap.tracking_number"/>
                </if>
                <!-- always save results, whatever we got back -->
                <set field="trackingStatus" from="responseMap.tracking_status"/>
                <set field="statusMap" from="null"/>
                <if condition="trackingStatus instanceof Map"><then>
                    <set field="statusString" from="trackingStatus.status"/>
                    <set field="statusMap" from="trackingStatus"/>
                </then><else>
                    <set field="statusString" from="trackingStatus?.toString()"/>
                </else></if>
                <if condition="statusString"><then>
                    <set field="trackingStatusEnumId" from="[UNKNOWN:'ShTsUnknown', DELIVERED:'ShTsDelivered',
                        TRANSIT:'ShTsTransit', FAILURE:'ShTsFailure', RETURNED:'ShTsReturned'].get(statusString)"/>
                    <set field="trackingStatusDate" from="ec.l10n.parseTimestamp(statusMap?.status_date, 'yyyy-MM-dd\'T\'HH:mm:ss.SSSZ')"/>
                    <set field="originalEta" from="packageRouteSeg.trackingOrigEta ?: responseMap.original_eta ?: responseMap.eta"/>

                    <service-call name="update#mantle.shipment.ShipmentPackageRouteSeg" in-map="[shipmentId:packageRouteSeg.shipmentId,
                            shipmentPackageSeqId:packageRouteSeg.shipmentPackageSeqId, shipmentRouteSegmentSeqId:packageRouteSeg.shipmentRouteSegmentSeqId,
                            gatewayMessage:(statusMap?.status_details ?: packageRouteSeg.gatewayMessage),
                            trackingStatusEnumId:trackingStatusEnumId, trackingStatusDate:trackingStatusDate,
                            trackingEta:responseMap.eta, trackingOrigEta:originalEta]"/>
                    <message>Package ${shipmentPackageSeqId} tracking number ${responseMap.tracking_number} current status ${statusString} on ${ec.l10n.format(trackingStatusDate, null)}</message>
                </then><else>
                    <message>Package ${shipmentPackageSeqId} tracking number ${responseMap.tracking_number} current status unknown (not yet picked up by carrier)</message>
                </else></if>

                <iterate list="responseMap.tracking_history" entry="historyMap">
                    <set field="trackingStatusDate" from="ec.l10n.parseTimestamp(historyMap.status_date, 'yyyy-MM-dd\'T\'HH:mm:ss.SSSZ')"/>
                    <message>History: (${historyMap.status}) ${historyMap.status_details} on ${ec.l10n.format(trackingStatusDate, null)}</message>
                </iterate>
            </iterate>
        </actions>
    </service>
    <service verb="update" noun="PackageTrack">
        <description>Mounted as a REST API endpoint to receive Shippo Webhook calls</description>
        <!-- See: https://goshippo.com/docs/webhooks and https://goshippo.com/docs/tracking -->
        <!-- Webhook path (see shippo.rest.xml): /rest/s1/shippo/track -->
        <!-- Local test:
        curl -X POST -H "Content-Type: application/json" \
             -d '{ "tracking_number":"92055901755477000000000015", "eta":"2018-02-03T00:00:00Z", "original_eta":"2018-02-01T00:00:00Z", "tracking_status":{ "status":"DELIVERED", "substatus":"delivered", "status_date":"2018-01-02T00:00:00Z", "status_details":"Test status update" } }' \
             http://localhost:8080/rest/s1/shippo/track
        -->
        <in-parameters>
            <parameter name="transaction"><description>For labels outside Shippo or in Shippo test messages this may be null</description></parameter>
            <parameter name="carrier"><description>Should always be populated, Shippo's carrier ID</description></parameter>
            <parameter name="tracking_number"/>
            <parameter name="eta" type="Timestamp"><description>By docs should be in ISO format, ie 2016-07-23T00:00:00Z</description></parameter>
            <parameter name="original_eta" type="Timestamp"><description>By docs should be in ISO format, ie 2016-07-23T00:00:00Z</description></parameter>
            <parameter name="tracking_status" type="Map">
                <parameter name="status"><description>May be: UNKNOWN, TRANSIT, DELIVERED, RETURNED, FAILURE</description></parameter>
                <parameter name="substatus"><description>For complete list see https://goshippo.com/docs/tracking#event-definitions</description></parameter>
                <parameter name="status_date" type="Timestamp"/>
                <parameter name="status_details"><description>Message with more details about status</description></parameter>
            </parameter>
        </in-parameters>
        <actions>
            <log message="Got Shippo tracking_update webhook call with: ${context}"/>

            <if condition="!tracking_number"><log level="error" message="Got tracking_update call from Shippo with no tracking_number parameter"/></if>
            <!-- <if condition="!transaction"><log message="Got tracking_update call from Shippo with no transaction parameter"/></if> -->
            <if condition="!tracking_number &amp;&amp; !transaction"><return/></if>

            <if condition="!tracking_status"><log level="error" message="Got tracking_update call from Shippo with no tracking_status map"/><return/></if>
            <if condition="!tracking_status.status"><log level="error" message="Got tracking_update call from Shippo with no tracking_status.status field"/><return/></if>

            <set field="shippoStatusMap" from="[UNKNOWN:'ShTsUnknown', DELIVERED:'ShTsDelivered', TRANSIT:'ShTsTransit', FAILURE:'ShTsFailure', RETURNED:'ShTsReturned']"/>

            <!-- original label -->
            <if condition="transaction">
                <entity-find entity-name="mantle.shipment.ShipmentPackageRouteSeg" list="sprsList">
                    <econdition field-name="gatewayLabelId" from="transaction"/></entity-find>
            </if>
            <if condition="tracking_number &amp;&amp; !sprsList">
                <entity-find entity-name="mantle.shipment.ShipmentPackageRouteSeg" list="sprsList">
                    <econdition field-name="trackingCode" from="tracking_number"/></entity-find>
            </if>
            <iterate list="sprsList" entry="sprs">
                <set field="originalEta" from="sprs.trackingOrigEta ?: original_eta ?: eta"/>
                <service-call name="update#mantle.shipment.ShipmentPackageRouteSeg" in-map="[shipmentId:sprs.shipmentId,
                        shipmentPackageSeqId:sprs.shipmentPackageSeqId, shipmentRouteSegmentSeqId:sprs.shipmentRouteSegmentSeqId,
                        gatewayMessage:(tracking_status.status_details ?: sprs.gatewayMessage),
                        trackingStatusEnumId:shippoStatusMap.get(tracking_status.status), trackingSubStatus:tracking_status.substatus,
                        trackingStatusDate:(tracking_status.status_date ?: ec.user.nowTimestamp),
                        trackingEta:eta, trackingOrigEta:originalEta]"/>
            </iterate>

            <!-- return label, if no match for original label -->
            <if condition="!sprsList">
                <if condition="transaction">
                    <entity-find entity-name="mantle.shipment.ShipmentPackageRouteSeg" list="sprsList">
                        <econdition field-name="returnGatewayLabelId" from="transaction"/></entity-find>
                </if>
                <if condition="tracking_number &amp;&amp; !sprsList">
                    <entity-find entity-name="mantle.shipment.ShipmentPackageRouteSeg" list="sprsList">
                        <econdition field-name="returnTrackingCode" from="tracking_number"/></entity-find>
                </if>
                <iterate list="sprsList" entry="sprs">
                    <service-call name="update#mantle.shipment.ShipmentPackageRouteSeg" in-map="[shipmentId:sprs.shipmentId,
                            shipmentPackageSeqId:sprs.shipmentPackageSeqId, shipmentRouteSegmentSeqId:sprs.shipmentRouteSegmentSeqId,
                            returnGatewayMessage:(tracking_status.status_details ?: sprs.gatewayMessage),
                            returnTrackingStatusEnumId:shippoStatusMap.get(tracking_status.status),
                            returnTrackingSubStatus:tracking_status.substatus,
                            returnTrackingStatusDate:(tracking_status.status_date ?: ec.user.nowTimestamp)]"/>
                </iterate>
            </if>

            <if condition="!sprsList"><log level="warn" message="No SPRS records found for Shippo tracking_update with transaction ${transaction} and tracking_number ${tracking_number}"/></if>
        </actions>
    </service>

    <!-- ================================================= -->
    <!-- ========== Address Validation Services ========== -->
    <!-- ================================================= -->

    <service verb="validate" noun="PostalAddress">
        <implements service="mantle.shipment.CarrierServices.validate#ShippingPostalAddress"/>
        <actions>
            <entity-find-one entity-name="mantle.party.contact.PostalAddress" value-field="postalAddress"/>
            <if condition="postalAddress == null"><return/></if>

            <!-- if PostalAddress has no shipGatewayAddressId look for one based on it (by ContactMech.replacesContactMechId) and if found return that) -->
            <if condition="!postalAddress.shipGatewayAddressId">
                <if condition="partyId"><then>
                    <entity-find entity-name="mantle.party.contact.PartyContactMechInfo" list="replacesPcmiList">
                        <date-filter/><econdition field-name="partyId"/>
                        <econdition field-name="replacesContactMechId" from="contactMechId"/>
                        <select-field field-name="contactMechId"/><order-by field-name="contactMechId"/>
                    </entity-find>
                    <if condition="replacesPcmiList"><set field="contactMechId" from="replacesPcmiList[0].contactMechId"/>
                        <return/></if>
                </then><else-if condition="facilityId">
                    <entity-find entity-name="mantle.facility.FacilityContactMechInfo" list="replacesFcmiList">
                        <date-filter/><econdition field-name="facilityId"/>
                        <econdition field-name="replacesContactMechId" from="contactMechId"/>
                        <select-field field-name="contactMechId"/><order-by field-name="contactMechId"/>
                    </entity-find>
                    <if condition="replacesFcmiList"><set field="contactMechId" from="replacesFcmiList[0].contactMechId"/>
                        <return/></if>
                </else-if></if>
            </if>

            <entity-find-one entity-name="mantle.shipment.carrier.ShippingGatewayOption" value-field="apiTokenOpt">
                <field-map field-name="shippingGatewayConfigId"/><field-map field-name="optionEnumId" value="SgoApiToken"/></entity-find-one>
            <set field="apiToken" from="apiTokenOpt?.optionValue"/>
            <if condition="!apiToken"><log level="warn" message="Shipping gateway ${shippingGatewayConfigId} has no SgoApiToken, not validating address"/><return/></if>

            <service-call name="mantle.shippo.ShippoServices.get#AddressMap" out-map="addrOut"
                    in-map="[postalAddress:postalAddress, partyId:partyId]"/>
            <set field="addressMap" from="addrOut.addressMap"/>

            <set field="addressMap.validate" from="true"/>
            <set field="addressMap.async" from="false"/>

            <!-- <log level="warn" message="Shippo validate address ${contactMechId} request:\n${addressMap}"/> -->

            <script><![CDATA[
                org.moqui.util.RestClient restClient = ec.service.rest().method(org.moqui.util.RestClient.POST)
                        .addHeader("Authorization", "ShippoToken ${apiToken}")
                        .addHeader("Shippo-API-Version", "2018-02-08")
                        .addHeader("Content-Type", "application/json").jsonObject(addressMap)
                restClient.uri().protocol("https").host("api.goshippo.com").port(443).path("addresses").build()
                org.moqui.util.RestClient.RestResponse restResponse = restClient.call()
                if (restResponse.statusCode < 200 || restResponse.statusCode >= 300) {
                    // based on code in Shippo Java client will return error message in plain text body
                    String errMsg = restResponse.text()
                    ec.logger.error("Shippo error response (${restResponse.statusCode}): ${errMsg}")
                    ec.message.addError(errMsg)
                    return
                }
                responseMap = restResponse.jsonObject()
            ]]></script>

            <!-- <log level="warn" message="Shippo validate address ${contactMechId} response: ${responseMap}"/> -->

            <set field="is_complete" from="responseMap.is_complete"/>
            <set field="is_valid" from="responseMap.validation_results ? responseMap.validation_results?.is_valid : true"/>
            <set field="trustLevelEnumId" from="(is_valid &amp;&amp; is_complete) ? 'CmtlValid' : (is_complete ? 'CmtlInvalid' : 'CmtlIncomplete')"/>

            <entity-find-one entity-name="mantle.party.contact.ContactMech" value-field="origContactMech"/>
            <set field="origContactMech.trustLevelEnumId" from="trustLevelEnumId"/>
            <entity-update value-field="origContactMech"/>

            <!-- call update#PartyPostalAddress for cleansed address -->
            <if condition="is_complete &amp;&amp; (partyId || facilityId)">
                <set field="stateProvinceGeoId" from="postalAddress.stateProvinceGeoId"/>
                <if condition="postalAddress.countryGeoId &amp;&amp; responseMap.state">
                    <entity-find entity-name="moqui.basic.GeoAssocAndToDetail" list="stateGeoList">
                        <econdition field-name="geoId" from="postalAddress.countryGeoId"/>
                        <econdition field-name="geoCodeAlpha2" from="responseMap.state"/>
                    </entity-find>
                    <if condition="stateGeoList"><set field="stateProvinceGeoId" from="stateGeoList[0].toGeoId"/></if>
                </if>
                <set field="paInMap" from="[contactMechId:contactMechId,
                        toName:(responseMap.company ? responseMap.company : responseMap.name), attnName:(responseMap.company ? responseMap.name : null),
                        address1:((responseMap.street_no ? responseMap.street_no + ' ' : '') + responseMap.street1),
                        address2:responseMap.street2, unitNumber:null, city:responseMap.city, stateProvinceGeoId:stateProvinceGeoId,
                        postalCode:(responseMap.zip.contains('-') ? responseMap.zip.substring(0, responseMap.zip.indexOf('-')) : responseMap.zip),
                        postalCodeExt:(responseMap.zip.contains('-') ? responseMap.zip.substring(responseMap.zip.indexOf('-') + 1) : ''),
                        commercial:(responseMap.is_residential != null &amp;&amp; !responseMap.is_residential ? 'Y' : 'N')]"/>
                <if condition="facilityId">
                    <entity-find entity-name="mantle.facility.FacilityContactMech" list="origFcmList">
                        <date-filter/>
                        <econdition field-name="facilityId"/>
                        <econdition field-name="contactMechId" from="contactMechId"/>
                    </entity-find>
                    <if condition="origFcmList">
                        <service-call name="mantle.facility.ContactServices.update#FacilityPostalAddress" out-map="paOut"
                                in-map="paInMap + [facilityId:facilityId, expireCurrent:true]"/>
                        <set field="contactMechId" from="paOut.contactMechId"/>
                        <entity-find-one entity-name="mantle.party.contact.PostalAddress" value-field="postalAddress"/>
                    </if>
                </if>
                <if condition="partyId">
                    <entity-find entity-name="mantle.party.contact.PartyContactMech" list="origPcmList">
                        <!-- NOTE: do without <date-filter/>, allow if address has ever been associated with Party -->
                        <econdition field-name="partyId"/><econdition field-name="contactMechId"/>
                    </entity-find>
                    <if condition="origPcmList">
                        <service-call name="mantle.party.ContactServices.update#PartyPostalAddress" out-map="paOut"
                                in-map="paInMap + [partyId:partyId, expireCurrent:false, contactMechPurposeId:'PostalShippingDest']"/>
                        <set field="contactMechId" from="paOut.contactMechId"/>
                        <entity-find-one entity-name="mantle.party.contact.PostalAddress" value-field="postalAddress"/>
                    </if>
                </if>
            </if>

            <log message="Shippo validate address ${contactMechId} complete? ${is_complete} valid? ${is_valid} trust ${trustLevelEnumId} commercial ${(responseMap.is_residential != null &amp;&amp; !responseMap.is_residential ? 'Y' : 'N')}"/>
            <!-- update contactMech (using latest contactMechId) -->
            <entity-find-one entity-name="mantle.party.contact.ContactMech" value-field="contactMech"/>
            <set field="contactMech.trustLevelEnumId" from="trustLevelEnumId"/>
            <if condition="responseMap.validation_results?.messages">
                <set field="validateMessage" value=""/>
                <iterate list="responseMap.validation_results.messages" entry="messageObj">
                    <!-- <log message="Shippo validate address ${contactMechId} complete? ${is_complete} valid? ${is_valid} trust ${trustLevelEnumId} message: ${messageObj}"/> -->
                    <set field="validateMessage" value="${validateMessage}(${messageObj.source}:${messageObj.code}) ${messageObj.text} "/>
                </iterate>
                <if condition="validateMessage.length() &gt; 255"><set field="validateMessage" from="validateMessage.substring(0,255)"/></if>
                <set field="contactMech.validateMessage" from="validateMessage"/>
            </if>
            <entity-update value-field="contactMech"/>

            <!-- update postalAddress -->
            <set field="postalAddress.shipGatewayAddressId" from="responseMap.object_id"/>
            <entity-update value-field="postalAddress"/>
        </actions>
    </service>

    <service verb="get" noun="AddressMap">
        <in-parameters>
            <parameter name="postalAddress" type="EntityValue" required="true"/>
            <parameter name="partyId"/>
            <parameter name="isOrigin" type="Boolean" default="false"/>
            <parameter name="otherPartyId"/>
        </in-parameters>
        <out-parameters><parameter name="addressMap" type="Map"/></out-parameters>
        <actions>
            <set field="contactMechId" from="postalAddress.contactMechId"/>
            <if condition="!partyId">
                <!-- try to find from related Party -->
                <entity-find entity-name="mantle.party.contact.PartyContactMech" list="pcmList">
                    <econdition field-name="contactMechId"/><select-field field-name="partyId"/></entity-find>
                <set field="partyIds" from="new HashSet(pcmList*.partyId)"/>
                <!-- only if there is only one Party associated with the address -->
                <if condition="partyIds.size() == 1"><set field="partyId" from="pcmList[0].partyId"/></if>
            </if>

            <!-- name/company fields -->
            <if condition="postalAddress.attnName"><then>
                <set field="name" from="postalAddress.attnName"/>
                <set field="company" from="postalAddress.toName"/>
            </then><else>
                <set field="name" from="postalAddress.toName"/>
                <set field="company" from="null"/>
            </else></if>
            <if condition="!name &amp;&amp; partyId">
                <entity-find-one entity-name="mantle.party.PartyDetail" value-field="partyDetail"><field-map field-name="partyId"/></entity-find-one>
                <if condition="partyDetail != null">
                    <set field="name" value="${partyDetail.firstName ? partyDetail.firstName + ' ' : ''}${partyDetail.lastName?:''}${partyDetail.organizationName?:''}"/></if>
            </if>
            <if condition="!name"><return error="true" message="No name found for address ${contactMechId}"/></if>
            <if condition="name.length() &gt; 35"><set field="name" from="name.substring(0, 35)"/></if>
            <if condition="company &amp;&amp; company.length() &gt; 35"><set field="company" from="company.substring(0, 35)"/></if>

            <!-- address fields -->
            <set field="street1" from="postalAddress.address1"/>
            <if condition="postalAddress.unitNumber"><set field="street1" from="street1 + ' #' + (String) postalAddress.unitNumber"/></if>
            <set field="stateProvinceGeo" from="postalAddress.stateProvinceGeo"/>
            <set field="countryGeo" from="postalAddress.countryGeo"/>

            <set field="fullZip" from="postalAddress.postalCode"/>
            <if condition="postalAddress.postalCodeExt &amp;&amp; postalAddress.postalCode != postalAddress.postalCodeExt">
                <set field="fullZip" value="${postalAddress.postalCode}-${postalAddress.postalCodeExt}"/></if>

            <!-- phone number -->
            <!-- from PostalAddress.telecomContactMechId, if one set -->
            <if condition="postalAddress.telecomContactMechId">
                <entity-find-one entity-name="mantle.party.contact.TelecomNumber" value-field="telecomNumber">
                    <field-map field-name="contactMechId" from="postalAddress.telecomContactMechId"/></entity-find-one>
                <if condition="telecomNumber != null">
                    <service-call name="mantle.party.ContactServices.clean#TelecomNumber" out-map="tnCleanOut" out-map-add-to-existing="false"
                            in-map="[countryCode:telecomNumber.countryCode, areaCode:telecomNumber.areaCode, contactNumber:telecomNumber.contactNumber]"/>
                    <if condition="tnCleanOut.isValid != null &amp;&amp; !tnCleanOut.isValid">
                        <log level="warn" message="Shippo for Party ${partyId} found invalid PostalAddress TelecomNumber ${telecomNumber.countryCode}-${telecomNumber.areaCode}-${telecomNumber.contactNumber}, not using"/>
                        <set field="telecomNumber" from="null"/>
                    </if>
                </if>
            </if>
            <!-- from Party's shipping origin (or dest) phone -->
            <if condition="telecomNumber == null &amp;&amp; partyId">
                <service-call name="mantle.party.ContactServices.get#PartyContactInfo" out-map="telecomInfo"
                        in-map="[partyId:partyId, telecomContactMechPurposeId:(isOrigin ? 'PhoneShippingOrigin' : 'PhoneShippingDest')]"/>
                <if condition="telecomInfo.telecomNumber != null">
                    <set field="telecomNumber" from="telecomInfo.telecomNumber"/>
                    <service-call name="mantle.party.ContactServices.clean#TelecomNumber" out-map="tnCleanOut" out-map-add-to-existing="false"
                            in-map="[countryCode:telecomNumber.countryCode, areaCode:telecomNumber.areaCode, contactNumber:telecomNumber.contactNumber]"/>
                    <if condition="tnCleanOut.isValid != null &amp;&amp; !tnCleanOut.isValid">
                        <log level="warn" message="Shippo for Party ${partyId} found invalid Party TelecomNumber ${telecomNumber.countryCode}-${telecomNumber.areaCode}-${telecomNumber.contactNumber}, not using"/>
                        <set field="telecomNumber" from="null"/>
                    </if>

                    <if condition="telecomNumber != null">
                        <set field="postalAddress.telecomContactMechId" from="telecomNumber.contactMechId"/>
                        <entity-update value-field="postalAddress"/>
                    </if>
                </if>
            </if>
            <!-- special case to default to from Party's ship dest phone for outgoing shipments when to Party has none -->
            <if condition="telecomNumber == null &amp;&amp; otherPartyId &amp;&amp; !isOrigin">
                <!-- for destination address if no phone default to 'PhoneShippingDest' purpose for otherParty (ship from party) -->
                <service-call name="mantle.party.ContactServices.get#PartyContactInfo" out-map="telecomInfo" out-map-add-to-existing="false"
                        in-map="[partyId:otherPartyId, telecomContactMechPurposeId:'PhoneShippingDest']"/>
                <if condition="telecomInfo.telecomNumber != null">
                    <set field="telecomNumber" from="telecomInfo.telecomNumber"/>
                </if>
            </if>
            <if condition="telecomNumber != null">
                <set field="phone" value="${telecomNumber.countryCode? telecomNumber.countryCode + '-' :''}${telecomNumber.areaCode? telecomNumber.areaCode + '-' :''}${telecomNumber.contactNumber?:''}"/></if>

            <!-- email address -->
            <if condition="postalAddress.emailContactMechId">
                <entity-find-one entity-name="mantle.party.contact.ContactMech" value-field="emailCm">
                    <field-map field-name="contactMechId" from="postalAddress.emailContactMechId"/></entity-find-one>
                <set field="email" from="emailCm?.infoString"/>
            </if>
            <if condition="!email &amp;&amp; partyId">
                <service-call name="mantle.party.ContactServices.get#PartyContactInfo" out-map="emailInfo"
                        in-map="[partyId:partyId, emailContactMechPurposeId:(isOrigin ? 'EmailShippingOrigin' : 'EmailShippingDest')]"/>
                <if condition="emailInfo.emailAddress">
                    <set field="email" from="emailInfo.emailAddress"/>
                    <set field="postalAddress.emailContactMechId" from="emailInfo.emailContactMechId"/>
                    <entity-update value-field="postalAddress"/>
                </if>
            </if>

            <!-- make the Map -->
            <set field="addressMap" from="[object_purpose:'PURCHASE', name:name, company:company,
                street1:street1, street2:postalAddress.address2, city:postalAddress.city,
                state:stateProvinceGeo?.geoCodeAlpha2, country:countryGeo?.geoCodeAlpha2, zip:fullZip,
                phone:phone, email:email]"/>
        </actions>
    </service>
</services>
